/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

class InvariantError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "InvariantError";
  }
}

export type ExactPartial<T> = {
  [P in keyof T]?: T[P] | undefined;
};

export function abortSignalAny(signals: AbortSignal[]): AbortSignal {
  const controller = new AbortController();
  const result = controller.signal;
  if (!signals.length) {
    return controller.signal;
  }

  if (signals.length === 1) {
    return signals[0] || controller.signal;
  }

  for (const signal of signals) {
    if (signal.aborted) {
      return signal;
    }
  }

  function abort(this: AbortSignal) {
    controller.abort(this.reason);
    clean();
  }

  const signalRefs: WeakRef<AbortSignal>[] = [];
  function clean() {
    for (const signalRef of signalRefs) {
      const signal = signalRef.deref();
      if (signal) {
        signal.removeEventListener("abort", abort);
      }
    }
  }

  for (const signal of signals) {
    signalRefs.push(new WeakRef(signal));
    signal.addEventListener("abort", abort);
  }

  return result;
}

export function allRequired<V extends Record<string, unknown>>(
  v: V,
):
  | {
      [K in keyof V]: NonNullable<V[K]>;
    }
  | undefined {
  if (Object.values(v).every((x) => x == null)) {
    return void 0;
  }

  return v as ReturnType<typeof allRequired<V>>;
}

export function combineSignals(
  ...signals: Array<AbortSignal | null | undefined>
): AbortSignal | null {
  const filtered: AbortSignal[] = [];
  for (const signal of signals) {
    if (signal) {
      filtered.push(signal);
    }
  }

  switch (filtered.length) {
    case 0:
    case 1:
      return filtered[0] || null;
    default:
      if ("any" in AbortSignal && typeof AbortSignal.any === "function") {
        return AbortSignal.any(filtered);
      }
      return abortSignalAny(filtered);
  }
}

export function compactMap<T>(
  values: Record<string, T | undefined>,
): Record<string, T> {
  const out: Record<string, T> = {};

  for (const [k, v] of Object.entries(values)) {
    if (typeof v !== "undefined") {
      out[k] = v;
    }
  }

  return out;
}

export function invariant(
  condition: unknown,
  message: string,
): asserts condition {
  if (!condition) {
    throw new InvariantError(message);
  }
}
